//类型

//整形
//char;unsigned char;signed char
//short;~ ~ (int);~ ~ (int)
//int;~~;~~
//long;~~(int);~~(int)

//浮点型
//float 单精度浮点型
//double 双精度浮点型

//构造类型
//数组类型 例: int [4]
//结构体类型 struct
//枚举类型 enum
//联合类型 union

//指针类型
//int *pi;char *pc;.....

//空类型:Void
//常用在不需要返回的函数


//原码、反码、补码

//计算机的整形有符号数的三种表现形式
//由符号位和数值位组成
//符号位的0表示正 1表示负

//原码:直接将正负翻译为二进制
//例子: int a= -10    //4个字节=32bit
//100000000000000000000000000001010 

//反码:源码符号位不变,其他位按位取反(负数)
//111111111111111111111111111111101

//补码:反码+1
//111111111111111111111111111111101

//对于正数,原码反码补码都相同.



//2进制翻译16进制
//1111 1111 1111 1111 1111 1111 1111 0110
//F       F       F        F          F      F      F      6
//0xFFFFFFF6
//内存:  f6 ff ff ff

//为什么对于整形来说,数据存放内存种其实存放的是补码
//使用补码:可以将符号位和数值域统一处理
//同时,加法和减法也可以统一处理（CPU只有加法器）
//例:  1+(-1)
//111111111111111111111111111111111111111
//+
//000000000000000000000000000000000000001
//=
//1000000000000000000000000000000000000000
//溢出=0


//大小端
//大端字节序存储模式:指数据低位储存在内存的高地址中，高位在低地址。
//小端字节序存储模式:数据的低位保存在内存的低地址中，高位在高地址。
//
#include <stdio.h>
//写一段代码判断当前机器的字节序.
//int check_sys (  )
//{
//	int a = 1;
//	return *(char*)&a;
//	//返回1，小端
//	//返回0，d大端
//}
//int main ()
//{
//	
//	//0x 00 00 00 14
//	//小端 14 00 00 00
//	//大端 00 00 00 14  
//	////低地址 ----  高地址
//	int ret = check_sys ();
//	if (ret == 1) //从起始位置向后访问一个字节
//	{
//		printf ( "小端" );
//	}
//	else
//	{
//		printf ( "大端" );
//	}
//	return 0;
//}
